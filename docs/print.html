<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Smart Contract Vulnerabilities</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="vulnerabilities/insufficient-gas-griefing.html"><strong aria-hidden="true">1.</strong> Insufficient Gas Griefing</a></li><li class="chapter-item expanded "><a href="vulnerabilities/reentrancy.html"><strong aria-hidden="true">2.</strong> Reentrancy</a></li><li class="chapter-item expanded "><a href="vulnerabilities/overflow-underflow.html"><strong aria-hidden="true">3.</strong> Integer Overflow and Underflow</a></li><li class="chapter-item expanded "><a href="vulnerabilities/timestamp-dependence.html"><strong aria-hidden="true">4.</strong> Timestamp Dependence</a></li><li class="chapter-item expanded "><a href="vulnerabilities/authorization-txorigin.html"><strong aria-hidden="true">5.</strong> Authorization Through tx.origin</a></li><li class="chapter-item expanded "><a href="vulnerabilities/floating-pragma.html"><strong aria-hidden="true">6.</strong> Floating Pragma</a></li><li class="chapter-item expanded "><a href="vulnerabilities/outdated-compiler-version.html"><strong aria-hidden="true">7.</strong> Outdated Compiler Version</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unsafe-low-level-call.html"><strong aria-hidden="true">8.</strong> Unsafe Low-Level Call</a></li><li class="chapter-item expanded "><a href="vulnerabilities/uninitialized-storage-pointer.html"><strong aria-hidden="true">9.</strong> Uninitialized Storage Pointer</a></li><li class="chapter-item expanded "><a href="vulnerabilities/assert-violation.html"><strong aria-hidden="true">10.</strong> Assert Violation</a></li><li class="chapter-item expanded "><a href="vulnerabilities/use-of-deprecated-functions.html"><strong aria-hidden="true">11.</strong> Use of Deprecated Functions</a></li><li class="chapter-item expanded "><a href="vulnerabilities/delegatecall-untrusted-callee.html"><strong aria-hidden="true">12.</strong> Delegatecall to Untrusted Callee</a></li><li class="chapter-item expanded "><a href="vulnerabilities/signature-malleability.html"><strong aria-hidden="true">13.</strong> Signature Malleability</a></li><li class="chapter-item expanded "><a href="vulnerabilities/incorrect-constructor.html"><strong aria-hidden="true">14.</strong> Incorrect Constructor Name</a></li><li class="chapter-item expanded "><a href="vulnerabilities/shadowing-state-variables.html"><strong aria-hidden="true">15.</strong> Shadowing State Variables</a></li><li class="chapter-item expanded "><a href="vulnerabilities/weak-sources-randomness.html"><strong aria-hidden="true">16.</strong> Weak Sources of Randomness from Chain Attributes</a></li><li class="chapter-item expanded "><a href="vulnerabilities/missing-protection-signature-replay.html"><strong aria-hidden="true">17.</strong> Missing Protection against Signature Replay Attacks</a></li><li class="chapter-item expanded "><a href="vulnerabilities/requirement-violation.html"><strong aria-hidden="true">18.</strong> Requirement Validation</a></li><li class="chapter-item expanded "><a href="vulnerabilities/arbitrary-storage-location.html"><strong aria-hidden="true">19.</strong> Write to Arbitrary Storage Location</a></li><li class="chapter-item expanded "><a href="vulnerabilities/incorrect-inheritance-order.html"><strong aria-hidden="true">20.</strong> Incorrect Inheritance Order</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unused-variables.html"><strong aria-hidden="true">21.</strong> Presence of Unused Variables</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unencrypted-private-data-on-chain.html"><strong aria-hidden="true">22.</strong> Unencrypted Private Data On-Chain</a></li><li class="chapter-item expanded "><a href="vulnerabilities/inadherence-to-standards.html"><strong aria-hidden="true">23.</strong> Inadherence to Standards</a></li><li class="chapter-item expanded "><a href="vulnerabilities/asserting-contract-from-code-size.html"><strong aria-hidden="true">24.</strong> Asserting Contract from Code Size</a></li><li class="chapter-item expanded "><a href="vulnerabilities/transaction-ordering-dependence.html"><strong aria-hidden="true">25.</strong> Transaction-Ordering Dependence</a></li><li class="chapter-item expanded "><a href="vulnerabilities/dos-gas-limit.html"><strong aria-hidden="true">26.</strong> DoS with Block Gas Limit</a></li><li class="chapter-item expanded "><a href="vulnerabilities/dos-revert.html"><strong aria-hidden="true">27.</strong> DoS with (Unexpected) revert</a></li><li class="chapter-item expanded "><a href="vulnerabilities/unexpected-ecrecover-null-address.html"><strong aria-hidden="true">28.</strong> Unexpected ecrecover null address</a></li><li class="chapter-item expanded "><a href="vulnerabilities/default-visibility.html"><strong aria-hidden="true">29.</strong> Default Visibility</a></li><li class="chapter-item expanded "><a href="vulnerabilities/insufficient-access-control.html"><strong aria-hidden="true">30.</strong> Insufficient Access Control</a></li><li class="chapter-item expanded "><a href="vulnerabilities/off-by-one.html"><strong aria-hidden="true">31.</strong> Off-By-One</a></li><li class="chapter-item expanded "><a href="vulnerabilities/lack-of-precision.html"><strong aria-hidden="true">32.</strong> Lack of Precision</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Smart Contract Vulnerabilities</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="insufficient-gas-griefing"><a class="header" href="#insufficient-gas-griefing">Insufficient Gas Griefing</a></h2>
<p>Insufficient gas griefing can be done on contracts which accept data and use it in a sub-call on another contract. This method is often used in multisignature wallets as well as transaction relayers. If the sub-call fails, either the whole transaction is reverted, or execution is continued.</p>
<p>Let's consider a simple relayer contract as an example. As shown below, the relayer contract allows someone to make and sign a transaction, without having to execute the transaction. Often this is used when a user can't pay for the gas associated with the transaction.</p>
<pre><code>contract Relayer {
    mapping (bytes =&gt; bool) executed;

    function relay(bytes _data) public {
        // replay protection; do not call the same transaction twice
        require(executed[_data] == 0, &quot;Duplicate call&quot;);
        executed[_data] = true;
        innerContract.call(bytes4(keccak256(&quot;execute(bytes)&quot;)), _data);
    }
}
</code></pre>
<p>The user who executes the transaction, the 'forwarder', can effectively censor transactions by using just enough gas so that the transaction executes, but not enough gas for the sub-call to succeed.</p>
<p>There are two ways this could be prevented. The first solution would be to only allow trusted users to relay transactions. The other solution is to require that the forwarder provides enough gas, as seen below.</p>
<pre><code>// contract called by Relayer
contract Executor {
    function execute(bytes _data, uint _gasLimit) {
        require(gasleft() &gt;= _gasLimit);
        ...
    }
}
</code></pre>
<h3 id="sources"><a class="header" href="#sources">Sources</a></h3>
<ul>
<li>https://consensys.github.io/smart-contract-best-practices/attacks/griefing/</li>
<li>https://ethereum.stackexchange.com/questions/62829/what-does-griefing-mean</li>
<li>https://ethereum.stackexchange.com/questions/73261/griefing-attacks-are-they-profitable-for-the-attacker</li>
<li>https://en.wikipedia.org/wiki/Griefer</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reentrancy"><a class="header" href="#reentrancy">Reentrancy</a></h2>
<p>Reentrancy is an attack that can occur when a bug in a contract may allow a malicious contract to reenter the contract unexpectedly during execution of the original function. This can be used to drain funds from a smart contract if used maliciously. Reentrancy is likely the single most impactful vulnerability in terms of total loss of funds by smart contract hacks, and should be considered accordingly. <a href="https://github.com/pcaversaccio/reentrancy-attacks">List of reentrancy attacks</a></p>
<h3 id="external-calls"><a class="header" href="#external-calls">External calls</a></h3>
<p>Reentrancy can be executed by the availability of an external call to an attacker controlled contract. External calls allow for the callee to execute arbitrary code. The existence of an external call may not always be obvious, so it's important to be aware of any way in which an external call may be executed in your smart contracts.</p>
<h5 id="eth-transfers"><a class="header" href="#eth-transfers">ETH transfers</a></h5>
<p>When Ether is transferred to a contract address, it will trigger the <code>receive</code> or <code>fallback</code> function, as implemented in the contract. An attacker can write any arbitrary logic into the <code>fallback</code> method, such that anytime the contract receives a transfer, that logic is executed. </p>
<h5 id="safemint"><a class="header" href="#safemint"><code>safeMint</code></a></h5>
<p>One example of a hard to spot external call is OpenZeppelin's <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3f610ebc25480bf6145e519c96e2f809996db8ed/contracts/token/ERC721/ERC721.sol#L244"><code>ERC721._safeMint</code></a> &amp; <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3f610ebc25480bf6145e519c96e2f809996db8ed/contracts/token/ERC721/ERC721.sol#L190"><code>ERC721._safeTransfer</code></a> functions.</p>
<pre><code>/**
  * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
  * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
  */
function _safeMint(
    address to,
    uint256 tokenId,
    bytes memory _data
) internal virtual {
    _mint(to, tokenId);
    require(
        _checkOnERC721Received(address(0), to, tokenId, _data),
        &quot;ERC721: transfer to non ERC721Receiver implementer&quot;
    );
}
</code></pre>
<p>The function is titled <code>_safeMint</code> because it prevents tokens from being unintentionally minted to a contract by checking first whether that contract has implemented ERC721Receiver, i.e. marking itself as a willing recipient of NFTs. This all seems fine, but <code>_checkOnERC721Received</code> is an external call to the receiving contract, allowing arbitrary execution.</p>
<h3 id="single-function-reentrancy"><a class="header" href="#single-function-reentrancy">Single function reentrancy</a></h3>
<p>A single function reentrancy attack occurs when a vulnerable function is the same function that an attacker is trying to recursively call.</p>
<pre><code>// UNSECURE
function withdraw() external {
    uint256 amount = balances[msg.sender];
    (bool success,) = msg.sender.call{value: balances[msg.sender]}(&quot;&quot;);
    require(success);
    balances[msg.sender] = 0;
}
</code></pre>
<p>Here we can see that the balance is only modified after the funds have been transferred. This can allow a hacker to call the function many times before the balance is set to 0, effectively draining the smart contract.</p>
<h3 id="cross-function-reentrancy"><a class="header" href="#cross-function-reentrancy">Cross-function reentrancy</a></h3>
<p>A cross-function reentrancy attack is a more complex version of the same process. Cross-function reentrancy occurs when a vulnerable function shares state with a function that an attacker can exploit.</p>
<pre><code>// UNSECURE
function transfer(address to, uint amount) external {
  if (balances[msg.sender] &gt;= amount) {
    balances[to] += amount;
    balances[msg.sender] -= amount;
  }
}

function withdraw() external {
  uint256 amount = balances[msg.sender];
  (bool success,) = msg.sender.call{value: balances[msg.sender]}(&quot;&quot;);
  require(success);
  balances[msg.sender] = 0;
}
</code></pre>
<p>In this example, a hacker can exploit this contract by having a fallback function call <code>transfer()</code> to transfer spent funds before the balance is set to 0 in the <code>withdraw()</code> function.</p>
<h3 id="read-only-reentrancy"><a class="header" href="#read-only-reentrancy">Read-only Reentrancy</a></h3>
<p>Read-only reentrancy is a novel attack vector in which instead of reentering into the same contract in which state changes have yet to be made, an attacker reenters into another contract which reads from the state of the original contract.</p>
<pre><code>// UNSECURE
contract A {
	// Has a reentrancy guard to prevent reentrancy
	// but makes state change only after external call to sender
	function withdraw() external nonReentrant {
		uint256 amount = balances[msg.sender];
		(bool success,) = msg.sender.call{value: balances[msg.sender]}(&quot;&quot;);
		require(success);
		balances[msg.sender] = 0;
	}
}

contract B {
	// Allows sender to claim equivalent B tokens for A tokens they hold
	function claim() external nonReentrant {
		require(!claimed[msg.sender]);
		balances[msg.sender] = A.balances[msg.sender];
		claimed[msg.sender] = true;
	}
}
</code></pre>
<p>As we can see in the above example, although both functions have a nonReentrant modifier, it is still possible for an attacker to call <code>B.claim</code> during the callback in <code>A.withdraw</code>, and since the attackers balance was not yet updated, execution succeeds.</p>
<h3 id="reentrancy-prevention"><a class="header" href="#reentrancy-prevention">Reentrancy prevention</a></h3>
<p>The simplest reentrancy prevention mechanism is to use a <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol"><code>ReentrancyGuard</code></a>, which allows you to add a modifier, e.g. <code>nonReentrant</code>, to functions which may otherwise be vulnerable. Although effective against most forms of reentrancy, it's important to understand how read-only reentrancy may be used to get around this and to always use the <strong>checks-effects-interactions pattern</strong>.</p>
<p>For optimum security, use the <strong>checks-effects-interactions pattern</strong>. This is a simple rule of thumb for ordering smart contract functions.</p>
<p>The function should begin with <em>checks</em>, e.g. <code>require</code> and <code>assert</code> statements.</p>
<p>Next, the <em>effects</em> of the contract should be performed, i.e. state modifications.</p>
<p>Finally, we can perform <em>interactions</em> with other smart contracts, e.g. external function calls.</p>
<p>This structure is effective against reentrancy because when an attacker reenters the function, the state changes have already been made. For example:</p>
<pre><code>function withdraw() external {
  uint256 amount = balances[msg.sender];
  balances[msg.sender] = 0;
  (bool success,) = msg.sender.call{value: balances[msg.sender]}(&quot;&quot;);
  require(success);
}
</code></pre>
<p>Since the balance is set to 0 before any interactions are performed, if the contract is called recursively, there is nothing to send after the first transaction.</p>
<p>Examples from: https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21</p>
<h3 id="sources-1"><a class="header" href="#sources-1">Sources</a></h3>
<ul>
<li>https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/</li>
<li>https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4</li>
<li>https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="integer-overflow-and-underflow"><a class="header" href="#integer-overflow-and-underflow">Integer Overflow and Underflow</a></h2>
<p>In solidity, integer types have maximum values. For example:</p>
<p><code>uint8</code> =&gt; 255
<code>uint16</code> =&gt; 65535
<code>uint24</code> =&gt; 16777215
<code>uint256</code> =&gt; (2^256) - 1</p>
<p>Overflow and underflow bugs can occur when you exceed the maximum value (overflow) or when you go below the minimum value (underflow). When you exceed the maximum value, you go back down to zero, and when you go below the minimum value, it brings you back up to the maximum value.</p>
<p>Since smaller integer types like: <code>uint8</code>, <code>uint16</code>, etc. have smaller maximum values, it can be easier to cause an overflow, thus they should be used with greater caution.</p>
<p>Older contracts often made use of the <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol">SafeMath library</a>, to avoid over/underflows, but in solidity &gt;=v0.8.0, SafeMath logic is built in by default. It's important to consider that regardless of SafeMath logic being used, either built-in or used manually in older contracts, over/underflows still trigger reverts, which may result in <a href="vulnerabilities/./dos-revert.html">denial of service</a> of important functionality or other unexpected effects. Built-in SafeMath logic may also be avoided with <code>unchecked</code> blocks, <a href="https://docs.soliditylang.org/en/v0.8.15/control-structures.html?highlight=unchecked#checked-or-unchecked-arithmetic">see docs for more info</a>.</p>
<h3 id="sources-2"><a class="header" href="#sources-2">Sources</a></h3>
<ul>
<li>https://consensys.github.io/smart-contract-best-practices/attacks/insecure-arithmetic/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="timestamp-dependence"><a class="header" href="#timestamp-dependence">Timestamp Dependence</a></h2>
<p><strong>NOTE: This vulnerability no longer affects Ethereum mainnet as of the Proof of Stake merge. <a href="https://ethereum.stackexchange.com/a/140818">Read more</a></strong></p>
<p>The timestamp of a block, accessed by <code>block.timestamp</code> or alias <code>now</code> can be manipulated by a miner. There are three considerations you should take into account when using a timestamp to execute a contract function.</p>
<h3 id="timestamp-manipulation"><a class="header" href="#timestamp-manipulation">Timestamp Manipulation</a></h3>
<p>If a timestamp is used in an attempt to generate randomness, a miner can post a timestamp within 15 seconds of block validation, giving them the ability to set the timestamp as a value that would increase their odds of benefitting from the function.</p>
<p>For example, a lottery application may use the block timestamp to pick a random bidder in a group. A miner may enter the lottery then modify the timestamp to a value that gives them better odds at winning the lottery.</p>
<p>Timestamps should thus not be used to create randomness. See <a href="vulnerabilities/weak-sources-randomness.html">Weak Sources of Randomness for Chain Attributes</a>.</p>
<h3 id="the-15-second-rule"><a class="header" href="#the-15-second-rule">The 15-second Rule</a></h3>
<p>Ethereum's reference specification, the Yellow Paper, doesn't specify a limit as to how much blocks can change in time, it just has to be bigger than the timestamp of it's parent. This being said, popular protocol implementations reject blocks with timestamps greater than 15 seconds in the future, so as long as your time-dependent event can safely vary by 15 seconds, it may be safe to use a block timestamp.</p>
<h3 id="dont-use-blocknumber-as-a-timestamp"><a class="header" href="#dont-use-blocknumber-as-a-timestamp">Don't use <code>block.number</code> as a timestamp</a></h3>
<p>You can estimate the time difference between events using <code>block.number</code> and the average block time, but block times may change and break the functionality, so it's best to avoid this use.</p>
<h3 id="sources-3"><a class="header" href="#sources-3">Sources</a></h3>
<ul>
<li>https://consensys.github.io/smart-contract-best-practices/attacks/timestamp-dependence/</li>
<li>https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/timestamp-dependence/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="authorization-through-txorigin"><a class="header" href="#authorization-through-txorigin">Authorization Through tx.origin</a></h2>
<p><code>tx.origin</code> is a global variable in Solidity which returns the address that sent a transaction. It's important that you never use <code>tx.origin</code> for authorization since another contract can use a fallback function to call your contract and gain authorization since the authorized address is stored in <code>tx.origin</code>. Consider this example:</p>
<pre><code>pragma solidity &gt;=0.5.0 &lt;0.7.0;

// THIS CONTRACT CONTAINS A BUG - DO NOT USE
contract TxUserWallet {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    function transferTo(address payable dest, uint amount) public {
        require(tx.origin == owner);
        dest.transfer(amount);
    }
}
</code></pre>
<p>Here we can see that the <code>TxUserWallet</code> contract authorizes the <code>transferTo()</code> function with <code>tx.origin</code>. </p>
<pre><code>pragma solidity &gt;=0.5.0 &lt;0.7.0;

interface TxUserWallet {
    function transferTo(address payable dest, uint amount) external;
}

contract TxAttackWallet {
    address payable owner;

    constructor() public {
        owner = msg.sender;
    }

    function() external {
        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);
    }
}
</code></pre>
<p>Now if someone were to trick you into sending ether to the <code>TxAttackWallet</code> contract address, they can steal your funds by checking <code>tx.origin</code> to find the address that sent the transaction.</p>
<p>To prevent this kind of attack, use <code>msg.sender</code> for authorization.</p>
<p>Examples from: https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin</p>
<h3 id="sources-4"><a class="header" href="#sources-4">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-115</li>
<li>https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin</li>
<li>https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/tx-origin/</li>
<li>https://github.com/sigp/solidity-security-blog#tx-origin</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="floating-pragma"><a class="header" href="#floating-pragma">Floating Pragma</a></h2>
<p>It is considered best practice to pick one compiler version and stick with it. With a floating pragma, contracts may accidentally be deployed using an outdated or problematic compiler version which can cause bugs, putting your smart contract's security in jeopardy. For open-source projects, the pragma also tells developers which version to use, should they deploy your contract. The chosen compiler version should be thoroughly tested and considered for known bugs. </p>
<p>The exception in which it is acceptable to use a floating pragma, is in the case of libraries and packages. Otherwise, developers would need to manually update the pragma to compile locally.</p>
<h3 id="sources-5"><a class="header" href="#sources-5">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-103</li>
<li>https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/locking-pragmas/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="outdated-compiler-version"><a class="header" href="#outdated-compiler-version">Outdated Compiler Version</a></h2>
<p>Developers often find bugs and vulnerabilities in existing software and make patches. For this reason, it's important to use the most recent compiler version possible. See bugs from past compiler versions <a href="https://solidity.readthedocs.io/en/latest/bugs.html">here</a>.</p>
<h3 id="sources-6"><a class="header" href="#sources-6">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-102</li>
<li>https://github.com/ethereum/solidity/releases</li>
<li>https://etherscan.io/solcbuginfo</li>
<li>https://solidity.readthedocs.io/en/latest/bugs.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-low-level-call"><a class="header" href="#unsafe-low-level-call">Unsafe Low-Level Call</a></h2>
<p>In Solidity, you can either use low-level calls such as: <code>address.call()</code>, <code>address.callcode()</code>, <code>address.delegatecall()</code>, and <code>address.send()</code>; or you can use contract calls such as: <code>ExternalContract.doSomething()</code>.</p>
<p>Low-level calls can be a good way to efficiently or arbitrarily make contract calls. However, it's important to be aware of the caveats it possesses. </p>
<h3 id="unchecked-call-return-value"><a class="header" href="#unchecked-call-return-value">Unchecked call return value</a></h3>
<p>Low-level calls will never throw an exception, instead they will return <code>false</code> if they encounter an exception, whereas contract calls will automatically throw. Thus if the return value of a low-level call is not checked, the execution may resume even if the function call throws an error. This can lead to unexpected behaviour and break the program logic. A failed call can even be caused intentionally by an attacker, who may be able to further exploit the application.</p>
<p>In the case that you use low-level calls, be sure to check the return value to handle possible failed calls, e.g.:</p>
<pre><code>// Simple transfer of 1 ether
(bool success,) = to.call{value: 1 ether}(&quot;&quot;);
// Revert if unsuccessful
require(success);
</code></pre>
<h3 id="successful-call-to-non-existent-contract"><a class="header" href="#successful-call-to-non-existent-contract">Successful call to non-existent contract</a></h3>
<p>As noted in the <a href="https://docs.soliditylang.org/en/v0.8.15/control-structures.html?highlight=low%20level%20calls#external-function-calls">Solidity docs</a>: &quot;Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity uses the <code>extcodesize</code> opcode to check that the contract that is about to be called actually exists (it contains code) and causes an exception if it does not. This check is skipped if the return data will be decoded after the call and thus the ABI decoder will catch the case of a non-existing contract.</p>
<p>Note that this check is not performed in case of <a href="https://docs.soliditylang.org/en/v0.8.15/units-and-global-variables.html#address-related">low-level calls</a> which operate on addresses rather than contract instances.&quot;</p>
<p>It's imperative that we do not simply assume that a contract to be called via a low-level call actually exists, since if it doesn't our logic will proceed even though our external call effectively failed. This can lead to loss of funds and/or an invalid contract state. Instead, we must verify that the contract being called exists, either immediately before being called with an <code>extcodesize</code> check, or by verifying during contract deployment and using a <code>constant</code>/<code>immutable</code> value if the contract can be fully trusted.</p>
<pre><code>// Verify address is a contract
require(to.code.length &gt; 0);
// Simple transfer of 1 ether
(bool success,) = to.call{value: 1 ether}(&quot;&quot;);
// Revert if unsuccessful
require(success);
</code></pre>
<h3 id="sources-7"><a class="header" href="#sources-7">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-104</li>
<li>https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="uninitialized-storage-pointer"><a class="header" href="#uninitialized-storage-pointer">Uninitialized Storage Pointer</a></h2>
<p>Data is stored in the EVM as either <code>storage</code>, <code>memory</code>, or <code>calldata</code>. It is important that they are well understood and correctly initialized. Incorrectly initializing data storage pointers, or simply leaving them uninitialized, can lead to contract vulnerabilities. </p>
<p>As of solidity <code>0.5.0</code>, uninitialized storage pointers are no longer an issue since contracts with uninitialized storage pointers will no longer compile. This being said, it's still important to understand what storage pointers you should be using in certain situations.</p>
<h3 id="sources-8"><a class="header" href="#sources-8">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-109</li>
<li>https://github.com/sigp/solidity-security-blog#storage</li>
<li>https://solidity.readthedocs.io/en/latest/types.html#data-location</li>
<li>https://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage</li>
<li>https://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-in-memory</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assert-violation"><a class="header" href="#assert-violation">Assert Violation</a></h2>
<p>In Solidity <code>0.4.10</code>, the following functions were created: <code>assert()</code>, <code>require()</code>, and <code>revert()</code>. Here we'll discuss the assert function and how to use it.</p>
<p>Formally said, the <code>assert()</code> funtion is meant to assert invariants; informally said, <code>assert()</code> is an overly assertive bodyguard that protects your contract, but steals your gas in the process. Properly functioning contracts should never reach a failing assert statement. If you've reached a failing assert statement, you've either improperly used <code>assert()</code>, or there is a bug in your contract that puts it in an invalid state.</p>
<p>If the condition checked in the <code>assert()</code> is not actually an invariant, it's suggested that you replace it with a <code>require()</code> statement.</p>
<h3 id="sources-9"><a class="header" href="#sources-9">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-110</li>
<li>https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="use-of-deprecated-functions"><a class="header" href="#use-of-deprecated-functions">Use of Deprecated Functions</a></h2>
<p>As time goes by, functions and operators in Solidity are deprecated and often replaced. It's important to not use deprecated functions, as it can lead to unexpected effects and compilation errors.</p>
<p>Here is a <em>non-exhaustive</em> list of deprecated functions and alternatives. Many alternatives are simply aliases, and won't break current behaviour if used as a replacement for its deprecated counterpart.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Deprecated</th><th style="text-align: right">Alternatives</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>suicide(address)</code></td><td style="text-align: right"><code>selfdestruct(address)</code></td></tr>
<tr><td style="text-align: left"><code>block.blockhash(uint)</code></td><td style="text-align: right"><code>blockhash(uint)</code></td></tr>
<tr><td style="text-align: left"><code>sha3(...)</code></td><td style="text-align: right"><code>keccak256(...)</code></td></tr>
<tr><td style="text-align: left"><code>callcode(...)</code></td><td style="text-align: right"><code>delegatecall(...)</code></td></tr>
<tr><td style="text-align: left"><code>throw</code></td><td style="text-align: right"><code>revert()</code></td></tr>
<tr><td style="text-align: left"><code>msg.gas</code></td><td style="text-align: right"><code>gasleft</code></td></tr>
<tr><td style="text-align: left"><code>constant</code></td><td style="text-align: right"><code>view</code></td></tr>
<tr><td style="text-align: left"><code>var</code></td><td style="text-align: right"><code>corresponding type name</code></td></tr>
</tbody></table>
</div>
<h3 id="sources-10"><a class="header" href="#sources-10">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-111</li>
<li>https://github.com/ethereum/solidity/releases</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="delegatecall-to-untrusted-callee"><a class="header" href="#delegatecall-to-untrusted-callee">Delegatecall to Untrusted Callee</a></h2>
<p><code>Delegatecall</code> is a special variant of a message call. It is almost identical to a regular message call except the target address is executed in the context of the calling contract and <code>msg.sender</code> and <code>msg.value</code> remain the same. Essentially, <code>delegatecall</code> delegates other contracts to modify the calling contract's storage.</p>
<p>Since <code>delegatecall</code> gives so much control over a contract, it's very important to only use this with trusted contracts such as your own. If the target address comes from user input, be sure to verify that it is a trusted contract.</p>
<h3 id="sources-11"><a class="header" href="#sources-11">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-112</li>
<li>https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries</li>
<li>https://blog.sigmaprime.io/solidity-security.html#delegatecall</li>
<li>https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="signature-malleability"><a class="header" href="#signature-malleability">Signature Malleability</a></h2>
<p>It's generally assumed that a valid signature cannot be modified without the private key and remain valid. However, it is possible to modify and signature and maintain validity. One example of a system which is vulnerable to signature malleability is one in which validation as to whether an action can be executed is determined based on whether the signature has been previously used.</p>
<pre><code>// UNSECURE
require(!signatureUsed[signature]);

// Validate signer and perform state modifying logic
...

signatureUsed[signature] = true;
</code></pre>
<p>In the above example, we can see that the <code>signature</code> is saved in a <code>signatureUsed</code> mapping after execution and validated to not exist in that mapping before execution. The problem with this is that if the <code>signature</code> can be modified while maintaining valididty, the transaction can be repeated by an attacker.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h3>
<p>To understand how signature malleability works, we first need to understand a bit about elliptic curve cryptography. </p>
<p>An elliptic curve consists of all the points that satisfy an equation of the form:</p>
<p>$y^2 = x^3 + ax + b$</p>
<p>where</p>
<p>$4a^3 + 27b^2 \not= 0$ (to avoid singular points)</p>
<p>Some examples:</p>
<p><img src="vulnerabilities/./img/elliptic-curves.png" alt="Elliptic Curves" /></p>
<p>Note that the curves are always symmetrical about the x-axis</p>
<p>The curve used by Ethereum is secp256k1, which looks like:</p>
<p><img src="vulnerabilities/./img/secp256k1.png" alt="secp256k1" /></p>
<p>Now that we understand the basics of elliptic curve cryptography, we can dig into how signature malleability actually works on Ethereum. </p>
<p>Ethereum uses <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a> as it's signature scheme. ECDSA signatures consist of a pair of numbers, $(r, s)$, with an integer order $n$. As a result of the x-axis symmetry, if $(r, s)$ is a valid signature, then so is $(r, -s$ mod $n)$. </p>
<p>It's possible to calculate this complementary signature without knowing the private key used to produce it in the first place, which gives an attacker the ability to produce a second valid signature.</p>
<h3 id="mitigation"><a class="header" href="#mitigation">Mitigation</a></h3>
<p>To avoid this issue, it's imperative to recognize that validating that a signature is not reused is insufficient in enforcing that the transaction is not replayed.</p>
<h3 id="sources-12"><a class="header" href="#sources-12">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-117</li>
<li>https://eklitzke.org/bitcoin-transaction-malleability</li>
<li>https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="incorrect-constructor-name"><a class="header" href="#incorrect-constructor-name">Incorrect Constructor Name</a></h2>
<p>Before Solidity <code>0.4.22</code>, the only way to define a constructor was by creating a function with the contract name. In some cases this was problematic. For example, if a smart contract is re-used with a different name but the constructor function isn't also changed it simply becomes a regular, callable function. Similarly, it's possible for an attacker to create a contract with which a function appears to be the constructor but actually has one character replaced with a similar looking character, e.g. replacing an &quot;l&quot; with a &quot;1&quot;, allowing logic to be executed when it's only expected to be executed during contract creation.</p>
<p>Now with modern versions of Solidity, the constructor is defined with the <code>constructor</code> keyword, effectively deprecating this vulnerability. Thus the solution to this problem is simply to use modern Solidity compiler versions.</p>
<h3 id="sources-13"><a class="header" href="#sources-13">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-118</li>
<li>https://blog.sigmaprime.io/solidity-security.html#constructors</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="shadowing-state-variables"><a class="header" href="#shadowing-state-variables">Shadowing State Variables</a></h2>
<p>It is possible to use the same variable twice in Solidity, but it can lead to unintended side effects. This is especially difficult regarding working with multiple contracts. Take the following example:</p>
<pre><code>contract SuperContract {
  uint a = 1;
}

contract SubContract is SuperContract {
  uint a = 2;
}
</code></pre>
<p>Here we can see that <code>SubContract</code> inherits <code>SuperContract</code> and the variable <code>a</code> is defined twice with different values. Now say we use <code>a</code> to perform some function in <code>SubContract</code>, functionality inherited from <code>SuperContract</code> will no longer work since the value of <code>a</code> has been modified. </p>
<p>To avoid this vulnerability, it's important we check the entire smart contract system for ambiguities. It's also important to check for compiler warnings, as they can flag these ambiguities so long as they're in the smart contract.</p>
<h3 id="sources-14"><a class="header" href="#sources-14">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-119</li>
<li>https://github.com/ethereum/solidity/issues/2563</li>
<li>https://github.com/ethereum/solidity/issues/973</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="weak-sources-of-randomness-from-chain-attributes"><a class="header" href="#weak-sources-of-randomness-from-chain-attributes">Weak Sources of Randomness from Chain Attributes</a></h2>
<p>Using chain attributes for randomness, e.g.: <code>block.timestamp</code>, <code>blockhash</code>, and <code>block.difficulty</code> can seem like a good idea since they often produce pseudo-random values. The problem however, is that Ethereum is entirely deterministic and all available on-chain data is public. Chain attributes can either be predicted or manipulated, and should thus never be used for random number generation.</p>
<p>A common solution is to use an oracle solution such as <a href="https://docs.chain.link/vrf/v2/introduction/">Chainlink VRF</a>.</p>
<h3 id="sources-15"><a class="header" href="#sources-15">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-120</li>
<li>https://ethereum.stackexchange.com/questions/419/when-can-blockhash-be-safely-used-for-a-random-number-when-would-it-be-unsafe</li>
<li>https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract</li>
<li>https://fravoll.github.io/solidity-patterns/randomness.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="missing-protection-against-signature-replay-attacks"><a class="header" href="#missing-protection-against-signature-replay-attacks">Missing Protection against Signature Replay Attacks</a></h2>
<p>Sometimes in smart contracts it is necessary to perform signature verification to improve usability and gas cost. However, consideration needs to be taken when implementing signature verification. To protect against Signature Replay Attacks, the contract should only be allowing new hashes to be processed. This prevents malicious users from replaying another users signature multiple times.</p>
<p>To be extra safe with signature verification, follow these recommendations:</p>
<ul>
<li>Store every message hash processed by the contract, then check messages hashes against the existing ones before executing the function.</li>
<li>Include the address of the contract in the hash to ensure that the message is only used in a single contract.</li>
<li>Never generate the message hash including the signature. See <a href="vulnerabilities/./signature-malleability.html">Signature Malleability</a></li>
</ul>
<h3 id="sources-16"><a class="header" href="#sources-16">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-121</li>
<li>https://medium.com/cypher-core/replay-attack-vulnerability-in-ethereum-smart-contracts-introduced-by-transferproxy-124bf3694e25</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="requirement-violation"><a class="header" href="#requirement-violation">Requirement Violation</a></h2>
<p>The <code>require()</code> method is meant to validate conditions, such as inputs or contract state variables, or to validate return values from external contract calls. For validating external calls, inputs can be provided by callers, or they can be returned by callees. In the case that an input violation has occured by the return value of a callee, likely one of two things has gone wrong:</p>
<ul>
<li>There is a bug in the contract that provided the input.</li>
<li>The requirement condition is too strong.</li>
</ul>
<p>To solve this issue, first consider whether the requirement condition is too strong. If necessary, weaken it to allow any valid external input. If the problem isn't the requirement condition, there must be a bug in the contract providing external input. Ensure that this contract is not providing invalid inputs.</p>
<h3 id="sources-17"><a class="header" href="#sources-17">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-123</li>
<li>https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="write-to-arbitrary-storage-location"><a class="header" href="#write-to-arbitrary-storage-location">Write to Arbitrary Storage Location</a></h2>
<p>Only authorized addresses should have access to write to sensitive storage locations. If there isn't proper authorization checks throughout the contract, a malicious user may be able to overwrite sensitive data. However, even if there are authorization checks for writing to sensitive data, an attacker may still be able to overwrite the sensitive data via insensitive data. This could give an attacker access to overwrite important variables such as the contract owner. </p>
<p>To prevent this from occuring, we not only want to protect sensitive data stores with authorization requirements, but we also want to ensure that writes to one data structure cannot inadvertently overwrite entries of another data structure.</p>
<p>For an example, try <a href="https://ethernaut.openzeppelin.com/level/19">Ethernaut - Alien Codex</a>. If it's too hard, see <a href="https://github.com/theNvN/ethernaut-openzeppelin-hacks/blob/main/level_19_Alien-Codex.md">this walkthrough (SPOILER)</a>.</p>
<h3 id="sources-18"><a class="header" href="#sources-18">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-124</li>
<li>https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="incorrect-inheritance-order"><a class="header" href="#incorrect-inheritance-order">Incorrect Inheritance Order</a></h2>
<p>In Solidity, it is possible to inherit from multiple sources, which if not properly understood can introduce ambiguity. This ambiguity is known as the Diamond Problem, wherein if two base contracts have the same functon, which one should be prioritized? Luckily, Solidity handles this problem gracefully, that is as long as the developer understands the solution. </p>
<p>The solution Solidity provides to the Diamond Problem is by using reverse C3 linearization. This means that it will linearize the inheritance from right to left, so the order of inheritance matters. It is suggested to start with more general contracts and end with more specific contracts to avoid problems.</p>
<h3 id="sources-19"><a class="header" href="#sources-19">Sources</a></h3>
<ul>
<li>https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/complex-inheritance/</li>
<li>https://solidity.readthedocs.io/en/v0.4.25/contracts.html#multiple-inheritance-and-linearization</li>
<li>https://pdaian.com/blog/solidity-anti-patterns-fun-with-inheritance-dag-abuse/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="presence-of-unused-variables"><a class="header" href="#presence-of-unused-variables">Presence of Unused Variables</a></h2>
<p>Although it is allowed, it is best practice to avoid unused variables. Unused variables can lead to a few different problems:</p>
<ul>
<li>Increase in computations (unnecessary gas consumption)</li>
<li>Indication of bugs or malformed data structures</li>
<li>Decreased code readability</li>
</ul>
<p>It is highly recommended to remove all unused variables from a code base.</p>
<h3 id="sources-20"><a class="header" href="#sources-20">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-131</li>
<li>https://github.com/ethereum/solidity/issues/718</li>
<li>https://github.com/ethereum/solidity/issues/2563</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unencrypted-private-data-on-chain"><a class="header" href="#unencrypted-private-data-on-chain">Unencrypted Private Data On-Chain</a></h2>
<p>Ethereum smart contract code, storage, and any data transacted on-chain can always be read. Treat it as such. Even if your code is not verified on Etherscan, attackers can still decompile or check transactions to and from it to analyze it. For this reason, it's imperative that private data is never stored on-chain unencrypted.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="inadherence-to-standards"><a class="header" href="#inadherence-to-standards">Inadherence to Standards</a></h2>
<p>In terms of smart contract development, it's important to follow standards. Standards are set to prevent vulnerabilities, and ignoring them can lead to unexpected effects.</p>
<p>Take for example binance's original BNB token. It was marketed as an ERC20 token, but it was later pointed out that it wasn't actually ERC20 compliant for a few reasons:</p>
<ul>
<li>It prevented sending to 0x0</li>
<li>It blocked transfers of 0 value</li>
<li>It didn't return true or false for success or fail</li>
</ul>
<p>The main cause for concern with this improper implementation is that if it is used with a smart contract that expects an ERC-20 token, it will behave in unexpected ways. It could even get locked in the contract forever. </p>
<p>Although standards aren't always perfect, and may someday become antiquated, they foster proper expectations to provide for secure smart contracts.</p>
<p>Suggested by: <a href="https://github.com/RobertMCForster">RobertMCForster</a></p>
<h3 id="sources-21"><a class="header" href="#sources-21">Sources</a></h3>
<ul>
<li>https://finance.yahoo.com/news/bnb-really-erc-20-token-160013314.html</li>
<li>https://blog.goodaudience.com/binance-isnt-erc-20-7645909069a4</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asserting-contract-from-code-size"><a class="header" href="#asserting-contract-from-code-size">Asserting contract from Code Size</a></h2>
<p>A common method for asserting whether a sender is a contract or EOA has been to check the code size of the sender. This check asserts that if the sender has a code size &gt; 0 that it must be a contract and if not then it must be an EOA. For example:</p>
<pre><code>function mint(uint256 amount) public {
  if (msg.sender.code.length != 0) revert CallerNotEOA();
}
</code></pre>
<p>However, as noted in the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellow Paper</a>, &quot;During initialization code execution, EXTCODESIZE on the address should return zero, which is the length of the code of the account while CODESIZE should return the length of the initialization&quot;. </p>
<p><a href="https://github.com/0xKitsune/Ghost-Contract/blob/main/src/Ghost.sol">This repo</a> shows how we may exploit this logic by simply calling during creation of a new contract.</p>
<p>As we can see, it's important that we recognize that although we may be certain that an account with a non-zero codesize is a contract, we can't be certain that an account with a zero codesize is not a contract.</p>
<h3 id="sources-22"><a class="header" href="#sources-22">Sources</a></h3>
<ul>
<li>https://ethereum.github.io/yellowpaper/paper.pdf</li>
<li>https://github.com/0xKitsune/Ghost-Contract</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transaction-ordering-dependence"><a class="header" href="#transaction-ordering-dependence">Transaction-Ordering Dependence</a></h2>
<p>Transactions on Ethereum are grouped together in blocks which are processed on a semi-regular interval, 12 seconds. Before transactions are placed in blocks, they are broadcasted to the mempool where block builders can then proceed to place them as is economically optimal. What's important to understand here is that the mempool is public and thus anyone can see transactions before they're executed, giving them the power to frontrun by placing their own transaction executing the same, or a similar, action with a higher gas price. </p>
<p>Frontrunning has become prevalent as a result of generalized frontrunning bots becoming more and more common. These generalized frontrunners work by observing the mempool for profitable, replicable transactions which they can replace for their own benefit. <a href="https://www.paradigm.xyz/2020/08/ethereum-is-a-dark-forest">Ethereum is a Dark Forest</a>.</p>
<p>One solution to transaction-ordering dependence is to use a commit-reveal scheme in the case of information being submitted on-chain. This works by having the submitter send in a hash of the information, storing that on-chain along with the user address so that they may later reveal the answer along with the salt to prove that they were indeed correct. Another solution is to simply use a private mempool such as <a href="https://www.flashbots.net/">Flashbots</a>.</p>
<h3 id="sources-23"><a class="header" href="#sources-23">Sources</a></h3>
<ul>
<li>https://consensys.github.io/smart-contract-best-practices/known_attacks/#front-running-aka-transaction-ordering-dependence</li>
<li>https://users.encs.concordia.ca/~clark/papers/2019_wtsc_front.pdf</li>
<li>https://swcregistry.io/docs/SWC-114</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dos-with-block-gas-limit"><a class="header" href="#dos-with-block-gas-limit">DoS with Block Gas Limit</a></h2>
<p>One of the primary benefits of a block gas limit is that it prevents attackers from creating an infinite transaction loop. If the gas usage of a transaction exceeds this limit, the transaction will fail. However, along with this benefit comes a side effect which is important to understand.</p>
<h3 id="unbounded-operations"><a class="header" href="#unbounded-operations">Unbounded Operations</a></h3>
<p>An example in which the block gas limit can be an issue is in executing logic in an unbounded loop. Even without any malicious intent, this can easily go wrong. Just by e.g., having too large an array of users to send funds to can exceed the gas limit and prevent the transaction from ever succeeding, potentially permanently locking up funds.</p>
<p>This situation can also lead to an attack. Say a bad actor decides to create a significant amount of addresses, with each address being paid a small amount of funds from the smart contract. If done effectively, the transaction can be blocked indefinitely, possibly even preventing further transactions from going through.</p>
<p>An effective solution to this problem would be to use a pull payment system over the above push payment system. To do this, separate each payment into it's own transaction, and have the recipient call the function.</p>
<p>If, for some reason, you really need to loop through an array of unspecified length, at least expect it to potentially take multiple blocks, and allow it to be performed in multiple transactions - as seen in this example:</p>
<pre><code>struct Payee {
    address addr;
    uint256 value;
}

Payee[] payees;
uint256 nextPayeeIndex;

function payOut() {
    uint256 i = nextPayeeIndex;
    while (i &lt; payees.length &amp;&amp; msg.gas &gt; 200000) {
      payees[i].addr.send(payees[i].value);
      i++;
    }
    nextPayeeIndex = i;
}
</code></pre>
<h3 id="block-stuffing"><a class="header" href="#block-stuffing">Block Stuffing</a></h3>
<p>In some situations, your contract can be attacked with a block gas limit even if you don't loop through an array of unspecified length. An attacker can fill several blocks before a transaction can be processed by using a sufficiently high gas price.</p>
<p>This attack is done by issuing several transactions at a very high gas price. If the gas price is high enough, and the transactions consume enough gas, they can fill entire blocks and prevent other transactions from being processed. </p>
<p>Ethereum transactions require the sender to pay gas to disincentivize spam attacks, but in some situations, there can be enough incentive to go through with such an attack. For example, a block stuffing attack was used on a gambling Dapp, Fomo3D. The app had a countdown timer, and users could win a jackpot by being the last to purchase a key, except everytime a user bought a key, the timer would be extended. An attacker bought a key then stuffed the next 13 blocks in a row so they could win the jackpot.</p>
<p>To prevent such attacks from occuring, it's important to carefully consider whether it's safe to incorporate time-based actions in your application.</p>
<p>Example from: https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/</p>
<h3 id="sources-24"><a class="header" href="#sources-24">Sources</a></h3>
<ul>
<li>https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/</li>
<li>https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dos-with-unexpected-revert"><a class="header" href="#dos-with-unexpected-revert">DoS with (Unexpected) revert</a></h2>
<p>A DoS (Denial of Service) may be caused when logic is unable to be executed as a result of an unexpected revert. This can happen for a number of reasons and it's important to consider all the ways in which your logic may revert. The examples listed below are <em>non-exhaustive</em>.</p>
<h3 id="reverting-funds-transfer"><a class="header" href="#reverting-funds-transfer">Reverting funds transfer</a></h3>
<p>DoS (Denial of Service) attacks can occur in functions when you try to send funds to a user and the functionality relies on that fund transfer being successful. </p>
<p>This can be problematic in the case that the funds are sent to a smart contract created by a bad actor, since they can simply create a fallback function that reverts all payments. </p>
<p>For example:</p>
<pre><code>// INSECURE
contract Auction {
    address currentLeader;
    uint highestBid;

    function bid() payable {
        require(msg.value &gt; highestBid);

        require(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert

        currentLeader = msg.sender;
        highestBid = msg.value;
    }
}
</code></pre>
<p>As you can see in this example, if an attacker bids from a smart contract with a fallback function reverting all payments, they can never be refunded, and thus no one can ever make a higher bid.</p>
<p>This can also be problematic without an attacker present. For example, you may want to pay an array of users by iterating through the array, and of course you would want to make sure each user is properly paid. The problem here is that if one payment fails, the funtion is reverted and no one is paid. </p>
<pre><code>address[] private refundAddresses;
mapping (address =&gt; uint) public refunds;

// bad
function refundAll() public {
    for(uint x; x &lt; refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
        require(refundAddresses[x].send(refunds[refundAddresses[x]])) // doubly bad, now a single failure on send will hold up all funds
    }
}
</code></pre>
<p>An effective solution to this problem would be to use a pull payment system over the above push payment system. To do this, separate each payment into it's own transaction, and have the recipient call the function.</p>
<pre><code>contract auction {
    address highestBidder;
    uint highestBid;
    mapping(address =&gt; uint) refunds;

    function bid() payable external {
        require(msg.value &gt;= highestBid);

        if (highestBidder != address(0)) {
            refunds[highestBidder] += highestBid; // record the refund that this user can claim
        }

        highestBidder = msg.sender;
        highestBid = msg.value;
    }

    function withdrawRefund() external {
        uint refund = refunds[msg.sender];
        refunds[msg.sender] = 0;
        (bool success, ) = msg.sender.call.value(refund)(&quot;&quot;);
        require(success);
    }
}
</code></pre>
<p>Examples from: https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/
https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/</p>
<h3 id="overunderflow"><a class="header" href="#overunderflow">Over/Underflow</a></h3>
<p>Prior to SafeMath usage, whether built-in in solidity &gt;=0.8.0 or using a library, <a href="vulnerabilities/./overflow-underflow.html">over/underflows</a> would result in rolling over to the minimum/maxium value. Now that checked math is commonplace, it's important to recognize that the effect of checked under/overflows is a revert, which may DoS important logic. </p>
<p>Regardless of usage of checked math, it's necessary to ensure that any valid input will not result in an over/underflow. Take extra care when working with smaller integers e.g. <code>int8</code>/<code>uint8</code>, <code>int16</code>/<code>uint16</code>, <code>int24</code>/<code>uint24</code>, etc..</p>
<h3 id="unexpected-balance"><a class="header" href="#unexpected-balance">Unexpected Balance</a></h3>
<p>It's important to take caution in enforcing expected contract balances of tokens or Ether as those balances may be increased by an attacker to cause an unexpected revert. This is easily possible with ERC20 tokens by simply <code>transfer</code>ring to the contract, but is also possible with Ether by <a href="vulnerabilities/./forcibly-sending-ether.html">Forcibly sending Ether to a contract</a>.</p>
<p>Consider, for example, a contract which expects the Ether balance to be 0 for the first deposit to allow for custom accounting logic. An attacker may forcibly send Ether to the contract before the first deposit, causing all deposits to revert. </p>
<h3 id="sources-25"><a class="header" href="#sources-25">Sources</a></h3>
<ul>
<li>https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/</li>
<li>https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unexpected-ecrecover-null-address"><a class="header" href="#unexpected-ecrecover-null-address">Unexpected <code>ecrecover</code> Null Address</a></h2>
<p><code>ecrecover</code> is a precompiled built-in cryptographic function which recovers an address associated with the public key from an elliptic curve signature or <em>returns zero on error</em>. The parameters corresponding to the signature are <code>r</code>, <code>s</code> &amp; <code>v</code>.</p>
<p>As noted above, <code>ecrecover</code> will return zero on error. It's possible to do this deterministically by setting <code>v</code> as any positive number other than 27 or 28.</p>
<p><code>ecrecover</code> is often used to verify that the signer is an authorized account. The problem with this is that uninitialized or renounced authorization logic often sets the owner/admin address as <code>address(0)</code>, the same value which may be deterministically returned by <code>ecrecover</code>. This means that an unsecure contract may allow an attacker to spoof an authorized-only method into executing as though the authorized account is the signer.</p>
<pre><code>// UNSECURE
function setOwner(bytes32 newOwner, uint8 v, bytes32 r, bytes32 s) external {
	address signer = ecrecover(newOwner, v, r, s);
	require(signer == owner);
	owner = address(newOwner);
}
</code></pre>
<p>The above method is intended to only set a new <code>owner</code> if a valid signature from the existing <code>owner</code> is provided. However, as we know, if we set <code>v</code> to any value other than 27 or 28, the <code>signer</code> will be the null address and if the current owner is uninitialized or renounced, the <code>require</code> statement will succeed allowing an attacker to set themselves as <code>owner</code>.</p>
<p>We can mitigate this issue by reverting if the recovered <code>signer</code> address is null, e.g.:</p>
<pre><code>function setOwner(bytes32 newOwner, uint8 v, bytes32 r, bytes32 s) external {
	address signer = ecrecover(newOwnerHash, v, r, s);
	require(signer == owner &amp;&amp; signer != address(0));
	owner = address(newOwner);
}
</code></pre>
<h3 id="sources-26"><a class="header" href="#sources-26">Sources</a></h3>
<ul>
<li>https://docs.soliditylang.org/en/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions</li>
<li>https://ethereum.stackexchange.com/a/69329</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="default-visibility"><a class="header" href="#default-visibility">Default Visibility</a></h2>
<p>Visibility specifiers are used to determine where a function or variable can be accessed from. As explained in the <a href="https://docs.soliditylang.org/en/v0.8.15/cheatsheet.html?highlight=visibility#function-visibility-specifiers">solidity docs</a>: </p>
<ul>
<li><code>public</code>: visible externally and internally (creates a <a href="https://docs.soliditylang.org/en/v0.8.15/contracts.html#getter-functions">getter function</a> for storage/state variables)</li>
<li><code>private</code>: only visible in the current contract</li>
<li><code>external</code>: only visible externally (only for functions) - i.e. can only be message-called (via <code>this.func</code>)</li>
<li><code>internal</code>: only visible internally</li>
</ul>
<p>It's important to note that the default visibility is <code>public</code>, allowing access externally or internally by any contract or EOA. We can see how this may be a problem if a method is intended to only be accessible internally but is missing a visibility specifier.</p>
<p>Modern compilers should catch missing function visibility specifiers, but will generally allow missing state variable visibility specifiers. Regardless, it's important to be aware of the possible interactions which may occur as a result of default visibility specifiers for both functions and state variables.</p>
<h3 id="sources-27"><a class="header" href="#sources-27">Sources</a></h3>
<ul>
<li>https://swcregistry.io/docs/SWC-100</li>
<li>https://swcregistry.io/docs/SWC-108</li>
<li>https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/visibility/</li>
<li>https://github.com/sigp/solidity-security-blog#visibility</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="insufficient-access-control"><a class="header" href="#insufficient-access-control">Insufficient Access Control</a></h2>
<p>Access control is often imperative in management and ownership of smart contracts. It's important to consider ways in which access control may be circumvented, or insufficiently implemented and the corresponding consequences.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="off-by-one"><a class="header" href="#off-by-one">Off-By-One</a></h2>
<p>Off-by-one errors are a common mistake made by programmers in which the intended boundaries are incorrect by only one, though these errors may seem insignificant, the effect can easily be quite severe. </p>
<h3 id="array-lengths"><a class="header" href="#array-lengths">Array lengths</a></h3>
<p>Properly determining intended array lengths is a common source of off-by-one errors. Particularly since 0-indexing means the final value in an array is <code>array.length - 1</code>.</p>
<p>Consider for example a function intended to loop over a list of recipients to transfer funds to each user, but the loop length is incorrectly set.</p>
<pre><code>// Incorrectly sets upper bound to users.length - 1
// Final user in array doesn't receive token transfer
for (uint256 i; i &lt; users.length - 1; ++i) {
	token.transfer(users[i], 1 ether);
}
</code></pre>
<h3 id="incorrect-comparison-operator"><a class="header" href="#incorrect-comparison-operator">Incorrect comparison operator</a></h3>
<p>It's common for comparison operators to be off by one when, e.g. <code>&gt;</code> should be used in place of <code>&gt;=</code>. This is especially common when the logic includes some kind of negation, leading to mental friction in deciphering the intended vs implemented bounds.</p>
<p>Consider for example a Defi protocol with liquidation logic documented to liquidate a user only if their collateralization ratio is <em>below</em> 1e18.</p>
<pre><code>// Incorrectly liquidates if collateralizationRatio is == 1 ether
if (collateralizationRatio &gt; 1 ether) {
	...
} else {
	liquidate();
}
</code></pre>
<h3 id="sources-28"><a class="header" href="#sources-28">Sources</a></h3>
<ul>
<li>https://github.com/OpenCoreCH/smart-contract-auditing-heuristics#off-by-one-errors</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lack-of-precision"><a class="header" href="#lack-of-precision">Lack of Precision</a></h2>
<p>In Solidity, there are a limited variety of number types. Differently from many programming languages, floating point numbers are unsupported. Fixed point numbers are partially supported, but cannot be assigned to or from. The primary number type in Solidity are integers, of which resulting values of calculations are always rounded down.</p>
<p>Since division often results in a remainder, performing division with integers generally requires a lack of precision to some degree. To see how a lack of precision may cause a serious flaw, consider the following example in which we charge a fee for early withdrawals denominated in the number of days early that the withdrawal is made:</p>
<pre><code>uint256 daysEarly = withdrawalsOpenTimestamp - block.timestamp / 1 days
uint256 fee = amount / daysEarly * dailyFee
</code></pre>
<p>The problem with this is that in the case that a user withdraws 1.99 days early, since 1.99 will round down to 1, the user only pays about half the intended fee.</p>
<p>In general, we should ensure that numerators are sufficiently larger than denominators to avoid precision errors. A common solution to this problem is to use fixed point logic, i.e. raising integers to a sufficient number of decimals such that the lack of precision has minimal effect on the contract logic. A good rule of thumb is to raise numbers to 1e18 (commonly referred to as WAD).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
